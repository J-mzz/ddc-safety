n = 2;
x = sdpvar(n, 1);
order = 6;
vars = x;
d = 2*order;

TWO_DISK = 1;

rng(1)

%set geometry
C0 = [1.5; 0];
R0 = 0.5;

Cu = [0; -1];
Ru = 0.6;


Cu2 = [-1; 1];
Ru2 = 0.5;

%support sets
X0 = struct('ineq', R0^2 - sum((x - C0).^2), 'eq', []);
Xu = struct('ineq', Ru^2 - sum((x - Cu).^2), 'eq', []);
% X = struct('ineq', [], 'eq', []);
X = struct('ineq', [sum((x - Cu).^2) - (Ru)^2; sum((x - Cu).^2) - (Ru2)^2], 'eq', []);

utol = 0.01;
var_reduce = x(1);
red_term = x(1)^2 - (sum((x - Cu).^2) - (Ru+utol)^2);
red_term2 = x(1)^2 - (sum((x - Cu2).^2) - (Ru2+utol)^2);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parameters
eg = 2;
eps = 1;

Cons.df = 3;
Cons.dg = 1;
Cons.n = n;     % num of states
Cons.T = 40;    % num of samples

generated_data = getDataRND(eg,eps,Cons.T);
[A,B,xi] = getCons(generated_data,Cons);

N = [A B; -A -B];
if rank(N) ~= size(N,2)
    error('Not enough data collected!')
end

e = [eps*ones(Cons.n*Cons.T,1)+xi; eps*ones(Cons.n*Cons.T,1)-xi];
[N, e] = nontrivial_constraints(N, e);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%polynomials
f = [x(2); -x(1) + (1/3)*x(1)^3 - x(2)];
g = [0; 1];
% Ulim = 10;
% Ulim = 5;
Ulim = 4;

% [rho, crho, mrho] = polynomial(x, d);
% [psi, cpsi, mpsi] = polynomial(x, d); 
[rho, crho, mrho] = polynomial(x, d, 0);
[psi, cpsi, mpsi] = polynomial(x, d, 1);

%perform the grobner reduction on the boundary of the circles
rhou = yalmip_order2_reduce(rho, x(1), red_term);
coeff_u = coefficients(rhou, vars);

rhou2 = yalmip_order2_reduce(rho, x(1), red_term2);
coeff_u2 = coefficients(rhou2, vars);

% aff = rho*f + psi*g;
% div = jacobian(aff(1), x(1)) + jacobian(aff(2), x(2));

%psatz constraints

% [p_div, cons_div, coeff_div] = constraint_psatz(div, X, vars, d);
[p_0, cons_0, coeff_0] = constraint_psatz(rho - 1e-2, X0, vars, d);
[p_top, cons_top, coeff_top] = constraint_psatz(Ulim*rho - psi, X, vars, d);
[p_bot, cons_bot, coeff_bot] = constraint_psatz(Ulim*rho + psi, X, vars, d);

cons_u = [coeff_u==0];

if TWO_DISK
    cons_u = [cons_u; coeff_u2==0];
end

% coeff = [coeff_div; coeff_0; coeff_top; coeff_bot; crho; cpsi];
coeff = [coeff_0; coeff_top; coeff_bot; crho; cpsi];
cons = [cons_0; cons_top; cons_bot; cons_u];
opts = sdpsettings('solver', 'mosek', 'verbose', 1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
[~,~,vf] = polynomial(vars,Cons.df,1);
[~,~,vg] = polynomial(vars,Cons.dg,0);

[s1,c1] = polynomial(vars,d-4);
[s2,c2] = polynomial(vars,d-4);

dmax = max(d+Cons.dg-1, d+Cons.df-1);

Y = zeros(1, size(N,1), 'like', sdpvar);      % the polynomial matrix Y
for i = 1:size(N,1)
    Y(i) = polynomial(vars, dmax, 0);	% see (20) for size
end

D1 = [kron(jacobian(rho,vars),vf') kron(jacobian(psi,vars),vg')];
D2 = [rho*[jacobian(vf,x(1))' jacobian(vf,x(2))'] psi*[jacobian(vg,x(1))' jacobian(vg,x(2))']];

k = coefficients(-D1-D2-Y*N, vars);

coeff = [coeff; c1; c2];
cons = [cons;
    k==0;
    sos(-Y*e);
    sos(Y); sos(s1); sos(s2)];
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sol = solvesos(cons, 0, opts, coeff)


if sol.problem== 0
%% recovery
rho_rec = value(crho)'*mrho;
psi_rec = value(cpsi)'*mpsi;

rhof = polyval_func(rho_rec, vars);
psif = polyval_func(psi_rec, vars);

boxlim = 1000;
ode_opts = odeset('RelTol', 1e-7, 'Events', @(t, x) box_event(t, x, boxlim));


uf = @(x) psif(x)./rhof(x);
Ff = polyval_func(f, vars);
Gf = polyval_func(g, vars);

Fclosed = @(x) Ff(x) + uf(x).*Gf(x);


%% sampling 

Nsample = 100;
sampler = @() ball_sample(1, 2)'*R0 + C0;
traj = cell(Nsample, 1);
Tmax = 10;
for i = 1:Nsample
    x0_curr = sampler();
    traj{i} = ode23(@(t, x) Fclosed(x), [0, Tmax], x0_curr, ode_opts);
    traj{i}.u = uf(traj{i}.y);
end

%% plotting (nonrobust/ddc)

colors=linspecer(3);
blp = 3;

figure(12)
clf
theta = linspace(0, 2*pi, 150);
hold on
plot(C0(1) + R0*cos(theta), C0(2) + R0*sin(theta), 'k', 'LineWidth', 2)
plot(Cu(1) + Ru*cos(theta), Cu(2) + Ru*sin(theta), 'color', colors(2, :), 'LineWidth', 2)
plot(Cu2(1) + Ru2*cos(theta), Cu2(2) + Ru2*sin(theta), 'color', colors(2, :), 'LineWidth', 2)
% fimplicit(@(x1, x2) rhof([x1; x2]), [-1,1,-1,1]*blp, 'color', colors(1, :))
%fsurf(@(x1, x2) rhof([x1; x2]), [-1,1,-1,1]*blp)
xlabel('$x_1$', 'interpreter', 'latex')
xlabel('$x_2$', 'interpreter', 'latex')
title('Density Generated by Grobner Reduction', 'fontsize', 14)

for i = 1:Nsample
    plot(traj{i}.y(1, :), traj{i}.y(2, :), 'color', colors(3, :))
end


xlim(blp*[-1,1])
ylim(blp*[-1,1])
axis square

figure(14)
clf
hold on
for i = 1:Nsample
    plot(traj{i}.x, traj{i}.u, 'color', colors(1, :))
end
xl = xlim;
plot(xl, Ulim*[1, 1], 'color', 'k', 'LineWidth', 2)
plot(xl, -Ulim*[1, 1], 'color', 'k', 'LineWidth', 2)
plot(xl, 0*[1, 1], ':k', 'LineWidth', 2)

xlabel('$t$', 'interpreter', 'latex')
ylabel('$u(t)$', 'interpreter', 'latex')
title('Bounded Input Actuation', 'fontsize', 14)


end

%% quotient-constrained psatz
%now the fun part:
%
%
% *** I'M DUMB! ***
% no need for the quotient psatz. just coefficient equality
% mom_u = sym_moments([0; 1; 0; n-1], order);
% 
% 
% 
% [pw, base] = getexponentbase(vars, vars);
% [rb, cb] = find(base);
% v_monom = recovermonoms(mom_u.monom_int(:, rb), vars);
% % v_monom = prod((ones(size(mom_out.monom_int, 1), 1)*(vars')).^mom_out.monom_int, 2);
% v_order2 = v_monom(mom_u.index_order2);
% 
% %now reduce the monomials
% % alpha = 0.05;
% v_red = yalmip_order2_reduce(v_order2, x(1), red_term);;
% 
% v_monom_red = v_monom;
% v_monom_red(mom_u.index_order2) = v_red;
% 
% mom_u.monom_int = v_monom_red;
% 
% M_red = v_monom_red(mom_u.M_even);
% 
% 
% Gramu = sdpvar(size(M_red, 1), size(M_red, 1));
% sigmau = gram_multiply(mom_u, v_monom_red,  Gram0);
% 
% con_u= [Gramu>=0; coefficients(rhou - sigmau, vars)==0];
% coeff_u = reshape(Gramu, [], 1);





